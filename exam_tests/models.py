from django.db import models
from django.contrib.postgres.fields import ArrayField
from django.core.exceptions import ValidationError

from lessons.models import Content
from tojet.base_model import BaseModel
from exam_tests.enums import Difficulty
from lessons.models import Content
from tojet import settings
from tojet.base_model import BaseModel
from django.apps import apps  # For lazy model resolution


class Question(BaseModel):
    """
    Represents a question associated with quiz content.
    """
    content = models.ForeignKey(
        'lessons.Content',
        on_delete=models.CASCADE,
        related_name="questions",
        help_text="The content item this question belongs to."
    )
    text = models.TextField(
        help_text="The text of the question."
    )
    options = models.JSONField(
        help_text="Multiple-choice options in JSON format."
    )
    correct_answer = models.CharField(
        max_length=255,
        help_text="The correct answer key."
    )
    explanation = models.TextField(
        null=True,
        blank=True,
        help_text="Explanation for the correct answer."
    )
    important_points = models.TextField(
        null=True,
        blank=True,
        help_text="Important points for the correct answer."
    )
    is_ai_generated = models.BooleanField(
        default=False,
        help_text="Indicates whether the question was generated by AI."
    )
    difficulty = models.CharField(
        max_length=10,
        choices=Difficulty.choices(),
        default=Difficulty.MEDIUM.value,
        help_text="The difficulty level of the question."
    )
    tags = ArrayField(
        models.CharField(max_length=50),
        default=list,
        blank=True,
        help_text="Tags related to the question like Physics, Trigonometry."
    )
    score = models.FloatField(
        default=1.0,
        help_text="The score assigned to this question."
    )

    def clean(self):
        """
        Validate options and the correct answer.
        """
        if not isinstance(self.options, list) or len(self.options) < 2:
            raise ValidationError("Options must be a list with at least two items.")
        if self.correct_answer not in self.options:
            raise ValidationError("Correct answer must be one of the provided options.")
        super().clean()

    def __str__(self):
        return f"Question: {self.text} (AI Generated: {self.is_ai_generated})"


class UserAnswer(BaseModel):
    """
    Tracks a user's response to a question.
    """
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="answers",
        help_text="The user who answered the question."
    )
    question = models.ForeignKey(
        'exam_tests.Question',
        on_delete=models.CASCADE,
        related_name="responses",
        help_text="The question being answered."
    )
    selected_option = models.CharField(
        max_length=255,
        help_text="The option selected by the user."
    )
    is_correct = models.BooleanField(
        default=False,
        help_text="Indicates if the selected option was correct."
    )
    answered_at = models.DateTimeField(
        auto_now_add=True,
        help_text="The timestamp when the answer was submitted."
    )
    time_taken = models.PositiveIntegerField(
        null=True,
        blank=True,
        help_text="Time taken by the user to answer the question, in seconds."
    )
    attempt_number = models.PositiveIntegerField(
        default=1,
        help_text="The number of attempts the user has made on this question."
    )

    def save(self, *args, **kwargs):
        """
        Automatically determine if the selected option is correct before saving.
        """
        if not self.selected_option:
            raise ValidationError("Selected option cannot be empty.")
        self.is_correct = self.selected_option == self.question.correct_answer
        super().save(*args, **kwargs)

    def __str__(self):
        return f"Answer by {self.user.username} for {self.question.text}"


class Exam(BaseModel):
    """
    Represents an exam consisting of multiple questions.
    """
    title = models.CharField(
        max_length=255,
        help_text="The title of the exam."
    )
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="created_exams",
        help_text="The user who created this exam."
    )
    questions = models.ManyToManyField(
        Question,
        blank=True,
        related_name="exams",
        help_text="The questions included in this exam."
    )
    duration = models.PositiveIntegerField(
        help_text="Duration of the exam in minutes."
    )

    def total_questions(self):
        return self.questions.count()

    def __str__(self):
        return f"Exam: {self.title} (Questions: {self.total_questions()})"
